<!DOCTYPE html>
<html lang="en"></html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hausdorff Middle - Computational Geometry</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<div id="navbar-container"></div>
<script>
fetch('navbar.html')
    .then(response => response.text())
    .then(data => {
        document.getElementById('navbar-container').innerHTML = data;
        setActiveLink();
    });

    function setActiveLink() {
        const currentPage = window.location.pathname.split('/').pop() || 'index.html';
        const links = document.querySelectorAll('.navbar a');
        
        links.forEach(link => {
            const href = link.getAttribute('href');
            if (href === currentPage) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });
    }
</script>

<div class="github-link">
    <a href="https://github.com/Seazs/ComputationalGeoWebsite" target="_blank" title="GitHub Repository">
        <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 2C6.477 2 2 6.484 2 12.012c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.009-.868-.013-1.703-2.782.605-3.369-1.342-3.369-1.342-.454-1.154-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.004.07 1.532 1.032 1.532 1.032.892 1.53 2.341 1.089 2.91.833.091-.646.35-1.09.636-1.342-2.221-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.254-.446-1.274.098-2.656 0 0 .84-.27 2.75 1.025A9.564 9.564 0 0 1 12 6.844c.85.004 1.705.115 2.504.337 1.909-1.295 2.747-1.025 2.747-1.025.546 1.382.202 2.402.1 2.656.64.7 1.028 1.595 1.028 2.688 0 3.847-2.337 4.695-4.566 4.944.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.744 0 .268.18.579.688.481C19.138 20.19 22 16.437 22 12.012 22 6.484 17.523 2 12 2z"/>
        </svg>
        GitHub
    </a>
</div>
<body>
    <div class="container">
        <header>
            <h1>Hausdorff Distance animation</h1>
            <p class="subtitle">Computational Geometry - Shape Interpolation</p>
        </header>

        <div class="theory-box">
    <h2>ðŸŽ¯ Theoretical Concept</h2>
      <h3>Definition</h3>
      <p>Let's formally define the Hausdorff distance. </p>
      <p>Here is the definition of the directed Hausdorff distance between two sets of points. It is defined as the maximum distance of a point in one set to the closest point in the other set. It makes more sense seeing it as math : </p> 
      <img src="../images/equation/hausdorff_eq.png" class="center" alt="Hausdorff equation" width="34%">
      
      <p>Where d(a,b) is the Euclidian distance between two points.</p></p>
      <p>To make it more general, we can define the undirected Hausdorff distance, which is the maximum between the two directed Hausdorff distances. </p>
      <img src="../images/equation/haus_undirected.png" class="center" alt="Hausdorff equation" width="40%">
      
      <h3>Algorithms</h3>
        <h4>1) Brute force</h4>
        <p>A simple brute force algorithm for that would look something like this :</p>
        <embed type="text/txt" src="hausdorff_algo.txt"  width="500" height="200">
          
            <TD ALIGN=center>
            <script language="Javascript" SRC="js/fig3.js"></script>
            <MAP NAME="changeFig3">
              <AREA SHAPE="RECT" COORDS="345,255,368,279" 
                  HREF="javascript:previousIm()">
              <AREA SHAPE="RECT" COORDS="381,255,404,279" 
                  HREF="javascript:nextIm()">
            </MAP>
            <img SRC="https://cgm.cs.mcgill.ca/~godfried/teaching/cg-projects/98/normand/fig3_1.gif" NAME="BruteForceFig" 
              BORDER="0" WIDTH="436" HEIGHT="305" USEMAP="#changeFig3">
            <P><U>Figure 3 :</U>&nbsp; &nbsp; A nice animation taken from <A HREF="https://cgm.cs.mcgill.ca/~godfried/teaching/cg-projects/98/normand/main.html">here</A> showing the calculation of Hausdorff distance between two shapes.
          </TD>

          <p>To find the directed distance, such an algorithm runs in O(nm)+O(n)=O(nm). 
            That needs to be performed two times to get the undirected distance.</p>
        
        <h4>2) ATALLAH algorithm</h4>
        <a href="attalah_algo.html">Attalah</a>
        
      <!-- <p><script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.min.js"></script></p>
      <p><script src="../js/concept_1.js"></script><p> -->
    </div>

        <header>
            <h1> Demo </h1>
        </header>

            <div class="container">
        <h1>ðŸŽ¯ Hausdorff Distance Visualizer</h1>
        
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        
        <div class="controls">
            <button class="primary-btn" onclick="generateShapes()">Generate New Shapes</button>
            <button class="secondary-btn" onclick="startAnimation()">Start Animation</button>
            <button class="secondary-btn" onclick="pauseAnimation()">Pause</button>
            <button class="secondary-btn" onclick="resetAnimation()">Reset</button>
        </div>
        
        <div class="info-panel">
            <div class="step-info" id="stepInfo">Click "Start Animation" to begin the Hausdorff distance calculation</div>
            <div class="distance-info" id="distanceInfo"></div>
            <div id="finalResult"></div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Shape A (Red)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4834d4;"></div>
                <span>Shape B (Blue)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #feca57;"></div>
                <span>Current Point</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00d2d3;"></div>
                <span>Closest Point</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let shapeA = [];
        let shapeB = [];
        let animationState = {
            isRunning: false,
            currentPoint: 0,
            direction: 'AtoB', // 'AtoB' or 'BtoA'
            distances: [],
            maxDistanceAtoB: 0,
            maxDistanceBtoA: 0,
            hausdorffDistance: 0
        };
        
        // Generate random shapes
        function generateShapes() {
            shapeA = generateRandomShape(200, 300, 100, 12);
            shapeB = generateRandomShape(500, 300, 80, 10);
            resetAnimation();
            draw();
        }
        
        function generateRandomShape(centerX, centerY, radius, numPoints) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const r = radius + (Math.random() - 0.5) * radius * 0.4;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                points.push({x, y});
            }
            return points;
        }
        
        // Calculate distance between two points
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
        
        // Find closest point in set B to point p
        function findClosestPoint(p, setB) {
            let minDist = Infinity;
            let closestPoint = null;
            
            for (const point of setB) {
                const dist = distance(p, point);
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = point;
                }
            }
            
            return {point: closestPoint, distance: minDist};
        }
        
        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw shapes
            drawShape(shapeA, '#ff6b6b', 'Shape A');
            drawShape(shapeB, '#4834d4', 'Shape B');
            
            // Draw animation state
            if (animationState.isRunning || animationState.distances.length > 0) {
                drawAnimationState();
            }
        }
        
        function drawShape(shape, color, label) {
            // Draw shape outline
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < shape.length; i++) {
                const point = shape[i];
                if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            }
            ctx.closePath();
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = color;
            for (const point of shape) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawAnimationState() {
            const currentShape = animationState.direction === 'AtoB' ? shapeA : shapeB;
            const targetShape = animationState.direction === 'AtoB' ? shapeB : shapeA;
            
            if (animationState.currentPoint < currentShape.length) {
                const currentP = currentShape[animationState.currentPoint];
                const closest = findClosestPoint(currentP, targetShape);
                
                // Highlight current point
                ctx.fillStyle = '#feca57';
                ctx.beginPath();
                ctx.arc(currentP.x, currentP.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Highlight closest point
                ctx.fillStyle = '#00d2d3';
                ctx.beginPath();
                ctx.arc(closest.point.x, closest.point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw distance line
                ctx.strokeStyle = '#feca57';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(currentP.x, currentP.y);
                ctx.lineTo(closest.point.x, closest.point.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw distance text
                const midX = (currentP.x + closest.point.x) / 2;
                const midY = (currentP.y + closest.point.y) / 2;
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(closest.distance.toFixed(1), midX, midY - 10);
            }
        }
        
        function updateInfo() {
            const stepInfo = document.getElementById('stepInfo');
            const distanceInfo = document.getElementById('distanceInfo');
            const finalResult = document.getElementById('finalResult');
            
            if (!animationState.isRunning && animationState.distances.length === 0) {
                stepInfo.textContent = "Click 'Start Animation' to begin the Hausdorff distance calculation";
                distanceInfo.textContent = "";
                finalResult.innerHTML = "";
                return;
            }
            
            const currentShape = animationState.direction === 'AtoB' ? 'A' : 'B';
            const targetShape = animationState.direction === 'AtoB' ? 'B' : 'A';
            
            if (animationState.currentPoint < (animationState.direction === 'AtoB' ? shapeA.length : shapeB.length)) {
                stepInfo.textContent = `Step ${animationState.currentPoint + 1}: Finding closest point in Shape ${targetShape} to point ${animationState.currentPoint + 1} of Shape ${currentShape}`;
                
                const currentP = animationState.direction === 'AtoB' ? shapeA[animationState.currentPoint] : shapeB[animationState.currentPoint];
                const targetSet = animationState.direction === 'AtoB' ? shapeB : shapeA;
                const closest = findClosestPoint(currentP, targetSet);
                
                distanceInfo.textContent = `Distance: ${closest.distance.toFixed(2)}`;
            } else if (animationState.direction === 'AtoB' && animationState.maxDistanceBtoA === 0) {
                stepInfo.textContent = `Completed Shape A â†’ B. Max distance: ${animationState.maxDistanceAtoB.toFixed(2)}. Now calculating Shape B â†’ A...`;
                distanceInfo.textContent = "";
            } else {
                stepInfo.textContent = "Calculation complete!";
                distanceInfo.textContent = `Max distance Aâ†’B: ${animationState.maxDistanceAtoB.toFixed(2)}, Max distance Bâ†’A: ${animationState.maxDistanceBtoA.toFixed(2)}`;
                finalResult.innerHTML = `<div class="final-result">Hausdorff Distance: ${animationState.hausdorffDistance.toFixed(2)}</div>`;
            }
        }
        
        function startAnimation() {
            if (!animationState.isRunning) {
                animationState.isRunning = true;
                animate();
            }
        }
        
        function pauseAnimation() {
            animationState.isRunning = false;
        }
        
        function resetAnimation() {
            animationState = {
                isRunning: false,
                currentPoint: 0,
                direction: 'AtoB',
                distances: [],
                maxDistanceAtoB: 0,
                maxDistanceBtoA: 0,
                hausdorffDistance: 0
            };
            updateInfo();
            draw();
        }
        
        function animate() {
            if (!animationState.isRunning) return;
            
            const currentShape = animationState.direction === 'AtoB' ? shapeA : shapeB;
            const targetShape = animationState.direction === 'AtoB' ? shapeB : shapeA;
            
            if (animationState.currentPoint < currentShape.length) {
                const currentP = currentShape[animationState.currentPoint];
                const closest = findClosestPoint(currentP, targetShape);
                
                if (animationState.direction === 'AtoB') {
                    animationState.maxDistanceAtoB = Math.max(animationState.maxDistanceAtoB, closest.distance);
                } else {
                    animationState.maxDistanceBtoA = Math.max(animationState.maxDistanceBtoA, closest.distance);
                }
                
                draw();
                updateInfo();
                
                animationState.currentPoint++;
                setTimeout(animate, 1000); // 1 second delay between steps
            } else if (animationState.direction === 'AtoB') {
                // Switch to B to A
                animationState.direction = 'BtoA';
                animationState.currentPoint = 0;
                setTimeout(animate, 2000); // 2 second pause between directions
            } else {
                // Animation complete
                animationState.hausdorffDistance = Math.max(animationState.maxDistanceAtoB, animationState.maxDistanceBtoA);
                animationState.isRunning = false;
                updateInfo();
            }
        }
        
        // Initialize
        generateShapes();
    </script>
    
</body>
</html>